{"ast":null,"code":"'use client';\n\nimport { clearListState } from './clear-list-state.mjs';\nfunction getIndexFromKeyAfterPath(key, path) {\n  const split = key.substring(path.length + 1).split(\".\")[0];\n  return parseInt(split, 10);\n}\nfunction changeErrorIndices(path, index, errors, change) {\n  if (index === void 0) {\n    return errors;\n  }\n  const pathString = `${String(path)}`;\n  let clearedErrors = errors;\n  if (change === -1) {\n    clearedErrors = clearListState(`${pathString}.${index}`, clearedErrors);\n  }\n  const cloned = {\n    ...clearedErrors\n  };\n  const changedKeys = /* @__PURE__ */new Set();\n  Object.entries(clearedErrors).filter(([key]) => {\n    if (!key.startsWith(`${pathString}.`)) {\n      return false;\n    }\n    const currIndex = getIndexFromKeyAfterPath(key, pathString);\n    if (Number.isNaN(currIndex)) {\n      return false;\n    }\n    return currIndex >= index;\n  }).forEach(([key, value]) => {\n    const currIndex = getIndexFromKeyAfterPath(key, pathString);\n    const newKey = key.replace(`${pathString}.${currIndex}`, `${pathString}.${currIndex + change}`);\n    cloned[newKey] = value;\n    changedKeys.add(newKey);\n    if (!changedKeys.has(key)) {\n      delete cloned[key];\n    }\n  });\n  return cloned;\n}\nexport { changeErrorIndices };","map":{"version":3,"names":["getIndexFromKeyAfterPath","key","path","split","substring","length","parseInt","changeErrorIndices","index","errors","change","pathString","String","clearedErrors","clearListState","cloned","changedKeys","Set","Object","entries","filter","startsWith","currIndex","Number","isNaN","forEach","value","newKey","replace","add","has"],"sources":["/Users/virounikamina/pompom/node_modules/@mantine/form/src/lists/change-error-indices.ts"],"sourcesContent":["import { clearListState } from './clear-list-state';\n\n/**\n * Gets the part of the key after the path which can be an index\n */\nfunction getIndexFromKeyAfterPath(key: string, path: string): number {\n  const split = key.substring(path.length + 1).split('.')[0];\n  return parseInt(split, 10);\n}\n\n/**\n * Changes the indices of every error that is after the given `index` with the given `change` at the given `path`.\n * This requires that the errors are in the format of `path.index` and that the index is a number.\n */\nexport function changeErrorIndices<T extends Record<PropertyKey, any>>(\n  path: PropertyKey,\n  index: number | undefined,\n  errors: T,\n  change: 1 | -1\n): T {\n  if (index === undefined) {\n    return errors;\n  }\n  const pathString = `${String(path)}`;\n  let clearedErrors = errors;\n  // Remove all errors if the corresponding item was removed\n  if (change === -1) {\n    clearedErrors = clearListState(`${pathString}.${index}`, clearedErrors);\n  }\n\n  const cloned = { ...clearedErrors };\n  const changedKeys = new Set<string>();\n  Object.entries(clearedErrors)\n    .filter(([key]) => {\n      if (!key.startsWith(`${pathString}.`)) {\n        return false;\n      }\n      const currIndex = getIndexFromKeyAfterPath(key, pathString);\n      if (Number.isNaN(currIndex)) {\n        return false;\n      }\n      return currIndex >= index;\n    })\n    .forEach(([key, value]) => {\n      const currIndex = getIndexFromKeyAfterPath(key, pathString);\n\n      const newKey: keyof T = key.replace(\n        `${pathString}.${currIndex}`,\n        `${pathString}.${currIndex + change}`\n      );\n      cloned[newKey] = value;\n      changedKeys.add(newKey);\n      if (!changedKeys.has(key)) {\n        delete cloned[key];\n      }\n    });\n\n  return cloned;\n}\n"],"mappings":";;;AAEA,SAASA,wBAAwBA,CAACC,GAAG,EAAEC,IAAI,EAAE;EAC3C,MAAMC,KAAK,GAAGF,GAAG,CAACG,SAAS,CAACF,IAAI,CAACG,MAAM,GAAG,CAAC,CAAC,CAACF,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAC1D,OAAOG,QAAQ,CAACH,KAAK,EAAE,EAAE,CAAC;AAC5B;AACO,SAASI,kBAAkBA,CAACL,IAAI,EAAEM,KAAK,EAAEC,MAAM,EAAEC,MAAM,EAAE;EAC9D,IAAIF,KAAK,KAAK,KAAK,CAAC,EAAE;IACpB,OAAOC,MAAM;EACd;EACD,MAAME,UAAU,GAAI,GAAEC,MAAM,CAACV,IAAI,CAAE,EAAC;EACpC,IAAIW,aAAa,GAAGJ,MAAM;EAC1B,IAAIC,MAAM,KAAK,CAAC,CAAC,EAAE;IACjBG,aAAa,GAAGC,cAAc,CAAE,GAAEH,UAAW,IAAGH,KAAM,EAAC,EAAEK,aAAa,CAAC;EACxE;EACD,MAAME,MAAM,GAAG;IAAE,GAAGF;EAAa,CAAE;EACnC,MAAMG,WAAW,kBAAmB,IAAIC,GAAG,EAAE;EAC7CC,MAAM,CAACC,OAAO,CAACN,aAAa,CAAC,CAACO,MAAM,CAAC,CAAC,CAACnB,GAAG,CAAC,KAAK;IAC9C,IAAI,CAACA,GAAG,CAACoB,UAAU,CAAE,GAAEV,UAAW,GAAE,CAAC,EAAE;MACrC,OAAO,KAAK;IACb;IACD,MAAMW,SAAS,GAAGtB,wBAAwB,CAACC,GAAG,EAAEU,UAAU,CAAC;IAC3D,IAAIY,MAAM,CAACC,KAAK,CAACF,SAAS,CAAC,EAAE;MAC3B,OAAO,KAAK;IACb;IACD,OAAOA,SAAS,IAAId,KAAK;EAC1B,EAAC,CAACiB,OAAO,CAAC,CAAC,CAACxB,GAAG,EAAEyB,KAAK,CAAC,KAAK;IAC3B,MAAMJ,SAAS,GAAGtB,wBAAwB,CAACC,GAAG,EAAEU,UAAU,CAAC;IAC3D,MAAMgB,MAAM,GAAG1B,GAAG,CAAC2B,OAAO,CACvB,GAAEjB,UAAW,IAAGW,SAAU,EAAC,EAC3B,GAAEX,UAAW,IAAGW,SAAS,GAAGZ,MAAO,EAC1C,CAAK;IACDK,MAAM,CAACY,MAAM,CAAC,GAAGD,KAAK;IACtBV,WAAW,CAACa,GAAG,CAACF,MAAM,CAAC;IACvB,IAAI,CAACX,WAAW,CAACc,GAAG,CAAC7B,GAAG,CAAC,EAAE;MACzB,OAAOc,MAAM,CAACd,GAAG,CAAC;IACnB;EACL,CAAG,CAAC;EACF,OAAOc,MAAM;AACf"},"metadata":{},"sourceType":"module","externalDependencies":[]}