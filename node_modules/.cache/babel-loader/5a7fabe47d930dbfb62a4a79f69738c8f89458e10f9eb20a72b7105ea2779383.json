{"ast":null,"code":"'use client';\n\nimport { useState, useRef, useCallback } from 'react';\nimport isEqual from 'fast-deep-equal';\nimport { useFormActions } from './actions/actions.mjs';\nimport { filterErrors } from './filter-errors/filter-errors.mjs';\nimport { getInputOnChange } from './get-input-on-change/get-input-on-change.mjs';\nimport { getStatus } from './get-status/get-status.mjs';\nimport { clearListState } from './lists/clear-list-state.mjs';\nimport { changeErrorIndices } from './lists/change-error-indices.mjs';\nimport { reorderErrors } from './lists/reorder-errors.mjs';\nimport { getPath } from './paths/get-path.mjs';\nimport { setPath } from './paths/set-path.mjs';\nimport { reorderPath } from './paths/reorder-path.mjs';\nimport { insertPath } from './paths/insert-path.mjs';\nimport { removePath } from './paths/remove-path.mjs';\nimport { validateValues } from './validate/validate-values.mjs';\nimport { validateFieldValue } from './validate/validate-field-value.mjs';\nimport { shouldValidateOnChange } from './validate/should-validate-on-change.mjs';\nfunction useForm({\n  name,\n  initialValues,\n  initialErrors = {},\n  initialDirty = {},\n  initialTouched = {},\n  clearInputErrorOnChange = true,\n  validateInputOnChange = false,\n  validateInputOnBlur = false,\n  onValuesChange,\n  transformValues = values => values,\n  enhanceGetInputProps,\n  validate: rules\n} = {}) {\n  const [touched, setTouched] = useState(initialTouched);\n  const [dirty, setDirty] = useState(initialDirty);\n  const [values, _setValues] = useState(initialValues || {});\n  const [errors, _setErrors] = useState(filterErrors(initialErrors));\n  const [initialized, setInitialized] = useState(false);\n  const valuesSnapshot = useRef(initialValues || {});\n  const setValuesSnapshot = _values => {\n    valuesSnapshot.current = _values;\n  };\n  const initialize = useCallback(_values => {\n    if (!initialized) {\n      setInitialized(true);\n      _setValues(_values);\n      setValuesSnapshot(_values);\n    }\n  }, [initialized]);\n  const resetTouched = useCallback(() => setTouched({}), []);\n  const resetDirty = _values => {\n    const newSnapshot = _values ? {\n      ...values,\n      ..._values\n    } : values;\n    setValuesSnapshot(newSnapshot);\n    setDirty({});\n  };\n  const setErrors = useCallback(errs => _setErrors(current => filterErrors(typeof errs === \"function\" ? errs(current) : errs)), []);\n  const clearErrors = useCallback(() => _setErrors({}), []);\n  const reset = useCallback(() => {\n    _setValues(valuesSnapshot.current);\n    clearErrors();\n    setDirty({});\n    resetTouched();\n  }, []);\n  const setFieldError = useCallback((path, error) => setErrors(current => ({\n    ...current,\n    [path]: error\n  })), []);\n  const clearFieldError = useCallback(path => setErrors(current => {\n    if (typeof path !== \"string\") {\n      return current;\n    }\n    const clone = {\n      ...current\n    };\n    delete clone[path];\n    return clone;\n  }), []);\n  const clearFieldDirty = useCallback(path => setDirty(current => {\n    if (typeof path !== \"string\") {\n      return current;\n    }\n    const result = clearListState(path, current);\n    delete result[path];\n    return result;\n  }), []);\n  const setFieldValue = useCallback((path, value) => {\n    const shouldValidate = shouldValidateOnChange(path, validateInputOnChange);\n    clearFieldDirty(path);\n    setTouched(currentTouched => ({\n      ...currentTouched,\n      [path]: true\n    }));\n    _setValues(current => {\n      const result = setPath(path, value, current);\n      if (shouldValidate) {\n        const validationResults = validateFieldValue(path, rules, result);\n        validationResults.hasError ? setFieldError(path, validationResults.error) : clearFieldError(path);\n      }\n      onValuesChange?.(result, current);\n      return result;\n    });\n    !shouldValidate && clearInputErrorOnChange && setFieldError(path, null);\n  }, []);\n  const setValues = useCallback(payload => {\n    _setValues(currentValues => {\n      const valuesPartial = typeof payload === \"function\" ? payload(currentValues) : payload;\n      const result = {\n        ...currentValues,\n        ...valuesPartial\n      };\n      onValuesChange?.(result, currentValues);\n      return result;\n    });\n    clearInputErrorOnChange && clearErrors();\n  }, []);\n  const reorderListItem = useCallback((path, payload) => {\n    clearFieldDirty(path);\n    _setValues(current => {\n      const result = reorderPath(path, payload, current);\n      onValuesChange?.(result, current);\n      return result;\n    });\n    _setErrors(errs => reorderErrors(path, payload, errs));\n  }, []);\n  const removeListItem = useCallback((path, index) => {\n    clearFieldDirty(path);\n    _setValues(current => {\n      const result = removePath(path, index, current);\n      onValuesChange?.(result, current);\n      return result;\n    });\n    _setErrors(errs => changeErrorIndices(path, index, errs, -1));\n  }, []);\n  const insertListItem = useCallback((path, item, index) => {\n    clearFieldDirty(path);\n    _setValues(current => {\n      const result = insertPath(path, item, index, current);\n      onValuesChange?.(result, current);\n      return result;\n    });\n    _setErrors(errs => changeErrorIndices(path, index, errs, 1));\n  }, []);\n  const validate = useCallback(() => {\n    const results = validateValues(rules, values);\n    _setErrors(results.errors);\n    return results;\n  }, [values, rules]);\n  const validateField = useCallback(path => {\n    const results = validateFieldValue(path, rules, values);\n    results.hasError ? setFieldError(path, results.error) : clearFieldError(path);\n    return results;\n  }, [values, rules]);\n  const getInputProps = (path, {\n    type = \"input\",\n    withError = true,\n    withFocus = true,\n    ...otherOptions\n  } = {}) => {\n    const onChange = getInputOnChange(value => setFieldValue(path, value));\n    const payload = {\n      onChange\n    };\n    if (withError) {\n      payload.error = errors[path];\n    }\n    if (type === \"checkbox\") {\n      payload.checked = getPath(path, values);\n    } else {\n      payload.value = getPath(path, values);\n    }\n    if (withFocus) {\n      payload.onFocus = () => setTouched(current => ({\n        ...current,\n        [path]: true\n      }));\n      payload.onBlur = () => {\n        if (shouldValidateOnChange(path, validateInputOnBlur)) {\n          const validationResults = validateFieldValue(path, rules, values);\n          validationResults.hasError ? setFieldError(path, validationResults.error) : clearFieldError(path);\n        }\n      };\n    }\n    return Object.assign(payload, enhanceGetInputProps?.({\n      inputProps: payload,\n      field: path,\n      options: {\n        type,\n        withError,\n        withFocus,\n        ...otherOptions\n      },\n      form\n    }));\n  };\n  const onSubmit = (handleSubmit, handleValidationFailure) => event => {\n    event?.preventDefault();\n    const results = validate();\n    if (results.hasErrors) {\n      handleValidationFailure?.(results.errors, values, event);\n    } else {\n      handleSubmit?.(transformValues(values), event);\n    }\n  };\n  const getTransformedValues = input => transformValues(input || values);\n  const onReset = useCallback(event => {\n    event.preventDefault();\n    reset();\n  }, []);\n  const isDirty = path => {\n    if (path) {\n      const overriddenValue = getPath(path, dirty);\n      if (typeof overriddenValue === \"boolean\") {\n        return overriddenValue;\n      }\n      const sliceOfValues = getPath(path, values);\n      const sliceOfInitialValues = getPath(path, valuesSnapshot.current);\n      return !isEqual(sliceOfValues, sliceOfInitialValues);\n    }\n    const isOverridden = Object.keys(dirty).length > 0;\n    if (isOverridden) {\n      return getStatus(dirty);\n    }\n    return !isEqual(values, valuesSnapshot.current);\n  };\n  const isTouched = useCallback(path => getStatus(touched, path), [touched]);\n  const isValid = useCallback(path => path ? !validateFieldValue(path, rules, values).hasError : !validateValues(rules, values).hasErrors, [values, rules]);\n  const form = {\n    initialized,\n    values,\n    errors,\n    initialize,\n    setValues,\n    setInitialValues: setValuesSnapshot,\n    setErrors,\n    setFieldValue,\n    setFieldError,\n    clearFieldError,\n    clearErrors,\n    reset,\n    validate,\n    validateField,\n    reorderListItem,\n    removeListItem,\n    insertListItem,\n    getInputProps,\n    onSubmit,\n    onReset,\n    isDirty,\n    isTouched,\n    setTouched,\n    setDirty,\n    resetTouched,\n    resetDirty,\n    isValid,\n    getTransformedValues\n  };\n  useFormActions(name, form);\n  return form;\n}\nexport { useForm };","map":{"version":3,"names":["useForm","name","initialValues","initialErrors","initialDirty","initialTouched","clearInputErrorOnChange","validateInputOnChange","validateInputOnBlur","onValuesChange","transformValues","values","enhanceGetInputProps","validate","rules","touched","setTouched","useState","dirty","setDirty","_setValues","errors","_setErrors","filterErrors","initialized","setInitialized","valuesSnapshot","useRef","setValuesSnapshot","_values","current","initialize","useCallback","resetTouched","resetDirty","newSnapshot","setErrors","errs","clearErrors","reset","setFieldError","path","error","clearFieldError","clone","clearFieldDirty","result","clearListState","setFieldValue","value","shouldValidate","shouldValidateOnChange","currentTouched","setPath","validationResults","validateFieldValue","hasError","setValues","payload","currentValues","valuesPartial","reorderListItem","reorderPath","reorderErrors","removeListItem","index","removePath","changeErrorIndices","insertListItem","item","insertPath","results","validateValues","validateField","getInputProps","type","withError","withFocus","otherOptions","onChange","getInputOnChange","checked","getPath","onFocus","onBlur","Object","assign","inputProps","field","options","form","onSubmit","handleSubmit","handleValidationFailure","event","preventDefault","hasErrors","getTransformedValues","input","onReset","isDirty","overriddenValue","sliceOfValues","sliceOfInitialValues","isEqual","isOverridden","keys","length","getStatus","isTouched","isValid","setInitialValues","useFormActions"],"sources":["/Users/virounikamina/pompom/node_modules/@mantine/form/src/use-form.ts"],"sourcesContent":["import { useCallback, useRef, useState } from 'react';\nimport isEqual from 'fast-deep-equal';\nimport { useFormActions } from './actions';\nimport { filterErrors } from './filter-errors';\nimport { getInputOnChange } from './get-input-on-change';\nimport { getStatus } from './get-status';\nimport { changeErrorIndices, clearListState, reorderErrors } from './lists';\nimport { getPath, insertPath, removePath, reorderPath, setPath } from './paths';\nimport {\n  _TransformValues,\n  ClearErrors,\n  ClearFieldDirty,\n  ClearFieldError,\n  GetFieldStatus,\n  GetInputProps,\n  GetTransformedValues,\n  Initialize,\n  InsertListItem,\n  IsValid,\n  OnReset,\n  OnSubmit,\n  RemoveListItem,\n  ReorderListItem,\n  Reset,\n  ResetDirty,\n  SetErrors,\n  SetFieldError,\n  SetFieldValue,\n  SetValues,\n  UseFormInput,\n  UseFormReturnType,\n  Validate,\n  ValidateField,\n} from './types';\nimport { shouldValidateOnChange, validateFieldValue, validateValues } from './validate';\n\nexport function useForm<\n  Values = Record<string, unknown>,\n  TransformValues extends _TransformValues<Values> = (values: Values) => Values,\n>({\n  name,\n  initialValues,\n  initialErrors = {},\n  initialDirty = {},\n  initialTouched = {},\n  clearInputErrorOnChange = true,\n  validateInputOnChange = false,\n  validateInputOnBlur = false,\n  onValuesChange,\n  transformValues = ((values: Values) => values) as any,\n  enhanceGetInputProps,\n  validate: rules,\n}: UseFormInput<Values, TransformValues> = {}): UseFormReturnType<Values, TransformValues> {\n  const [touched, setTouched] = useState(initialTouched);\n  const [dirty, setDirty] = useState(initialDirty);\n  const [values, _setValues] = useState((initialValues || {}) as Values);\n  const [errors, _setErrors] = useState(filterErrors(initialErrors));\n  const [initialized, setInitialized] = useState(false);\n\n  const valuesSnapshot = useRef<Values>((initialValues || {}) as Values);\n  const setValuesSnapshot = (_values: Values) => {\n    valuesSnapshot.current = _values;\n  };\n\n  const initialize: Initialize<Values> = useCallback(\n    (_values) => {\n      if (!initialized) {\n        setInitialized(true);\n        _setValues(_values);\n        setValuesSnapshot(_values);\n      }\n    },\n    [initialized]\n  );\n\n  const resetTouched = useCallback(() => setTouched({}), []);\n  const resetDirty: ResetDirty<Values> = (_values) => {\n    const newSnapshot = _values ? { ...values, ..._values } : values;\n    setValuesSnapshot(newSnapshot as Values);\n    setDirty({});\n  };\n\n  const setErrors: SetErrors = useCallback(\n    (errs) =>\n      _setErrors((current) => filterErrors(typeof errs === 'function' ? errs(current) : errs)),\n    []\n  );\n\n  const clearErrors: ClearErrors = useCallback(() => _setErrors({}), []);\n  const reset: Reset = useCallback(() => {\n    _setValues(valuesSnapshot.current);\n    clearErrors();\n    setDirty({});\n    resetTouched();\n  }, []);\n\n  const setFieldError: SetFieldError<Values> = useCallback(\n    (path, error) => setErrors((current) => ({ ...current, [path]: error })),\n    []\n  );\n\n  const clearFieldError: ClearFieldError = useCallback(\n    (path) =>\n      setErrors((current) => {\n        if (typeof path !== 'string') {\n          return current;\n        }\n\n        const clone = { ...current };\n        delete clone[path];\n        return clone;\n      }),\n    []\n  );\n\n  const clearFieldDirty: ClearFieldDirty = useCallback(\n    (path) =>\n      setDirty((current) => {\n        if (typeof path !== 'string') {\n          return current;\n        }\n\n        const result = clearListState(path, current);\n        delete result[path];\n        return result;\n      }),\n    []\n  );\n\n  const setFieldValue: SetFieldValue<Values> = useCallback((path, value) => {\n    const shouldValidate = shouldValidateOnChange(path, validateInputOnChange);\n    clearFieldDirty(path);\n    setTouched((currentTouched) => ({ ...currentTouched, [path]: true }));\n    _setValues((current) => {\n      const result = setPath(path, value, current);\n\n      if (shouldValidate) {\n        const validationResults = validateFieldValue(path, rules, result);\n        validationResults.hasError\n          ? setFieldError(path, validationResults.error)\n          : clearFieldError(path);\n      }\n\n      onValuesChange?.(result, current);\n\n      return result;\n    });\n\n    !shouldValidate && clearInputErrorOnChange && setFieldError(path, null);\n  }, []);\n\n  const setValues: SetValues<Values> = useCallback((payload) => {\n    _setValues((currentValues) => {\n      const valuesPartial = typeof payload === 'function' ? payload(currentValues) : payload;\n      const result = { ...currentValues, ...valuesPartial };\n      onValuesChange?.(result, currentValues);\n      return result;\n    });\n    clearInputErrorOnChange && clearErrors();\n  }, []);\n\n  const reorderListItem: ReorderListItem<Values> = useCallback((path, payload) => {\n    clearFieldDirty(path);\n    _setValues((current) => {\n      const result = reorderPath(path, payload, current);\n      onValuesChange?.(result, current);\n      return result;\n    });\n    _setErrors((errs) => reorderErrors(path, payload, errs));\n  }, []);\n\n  const removeListItem: RemoveListItem<Values> = useCallback((path, index) => {\n    clearFieldDirty(path);\n    _setValues((current) => {\n      const result = removePath(path, index, current);\n      onValuesChange?.(result, current);\n      return result;\n    });\n    _setErrors((errs) => changeErrorIndices(path, index, errs, -1));\n  }, []);\n\n  const insertListItem: InsertListItem<Values> = useCallback((path, item, index) => {\n    clearFieldDirty(path);\n    _setValues((current) => {\n      const result = insertPath(path, item, index, current);\n      onValuesChange?.(result, current);\n      return result;\n    });\n    _setErrors((errs) => changeErrorIndices(path, index, errs, 1));\n  }, []);\n\n  const validate: Validate = useCallback(() => {\n    const results = validateValues(rules, values);\n    _setErrors(results.errors);\n    return results;\n  }, [values, rules]);\n\n  const validateField: ValidateField<Values> = useCallback(\n    (path) => {\n      const results = validateFieldValue(path, rules, values);\n      results.hasError ? setFieldError(path, results.error) : clearFieldError(path);\n      return results;\n    },\n    [values, rules]\n  );\n\n  const getInputProps: GetInputProps<Values> = (\n    path,\n    { type = 'input', withError = true, withFocus = true, ...otherOptions } = {}\n  ) => {\n    const onChange = getInputOnChange((value) => setFieldValue(path, value as any));\n    const payload: any = { onChange };\n\n    if (withError) {\n      payload.error = errors[path];\n    }\n\n    if (type === 'checkbox') {\n      payload.checked = getPath(path, values);\n    } else {\n      payload.value = getPath(path, values);\n    }\n\n    if (withFocus) {\n      payload.onFocus = () => setTouched((current) => ({ ...current, [path]: true }));\n      payload.onBlur = () => {\n        if (shouldValidateOnChange(path, validateInputOnBlur)) {\n          const validationResults = validateFieldValue(path, rules, values);\n\n          validationResults.hasError\n            ? setFieldError(path, validationResults.error)\n            : clearFieldError(path);\n        }\n      };\n    }\n\n    return Object.assign(\n      payload,\n      enhanceGetInputProps?.({\n        inputProps: payload,\n        field: path,\n        options: { type, withError, withFocus, ...otherOptions },\n        form,\n      })\n    );\n  };\n\n  const onSubmit: OnSubmit<Values, TransformValues> =\n    (handleSubmit, handleValidationFailure) => (event) => {\n      event?.preventDefault();\n      const results = validate();\n\n      if (results.hasErrors) {\n        handleValidationFailure?.(results.errors, values, event);\n      } else {\n        handleSubmit?.(transformValues(values) as any, event);\n      }\n    };\n\n  const getTransformedValues: GetTransformedValues<Values, TransformValues> = (input) =>\n    (transformValues as any)(input || values);\n\n  const onReset: OnReset = useCallback((event) => {\n    event.preventDefault();\n    reset();\n  }, []);\n\n  const isDirty: GetFieldStatus<Values> = (path) => {\n    if (path) {\n      const overriddenValue = getPath(path, dirty);\n      if (typeof overriddenValue === 'boolean') {\n        return overriddenValue;\n      }\n\n      const sliceOfValues = getPath(path, values);\n      const sliceOfInitialValues = getPath(path, valuesSnapshot.current);\n      return !isEqual(sliceOfValues, sliceOfInitialValues);\n    }\n\n    const isOverridden = Object.keys(dirty).length > 0;\n    if (isOverridden) {\n      return getStatus(dirty);\n    }\n\n    return !isEqual(values, valuesSnapshot.current);\n  };\n\n  const isTouched: GetFieldStatus<Values> = useCallback(\n    (path) => getStatus(touched, path),\n    [touched]\n  );\n\n  const isValid: IsValid<Values> = useCallback(\n    (path) =>\n      path\n        ? !validateFieldValue(path, rules, values).hasError\n        : !validateValues(rules, values).hasErrors,\n    [values, rules]\n  );\n\n  const form: UseFormReturnType<Values, TransformValues> = {\n    initialized,\n    values,\n    errors,\n    initialize,\n    setValues,\n    setInitialValues: setValuesSnapshot,\n    setErrors,\n    setFieldValue,\n    setFieldError,\n    clearFieldError,\n    clearErrors,\n    reset,\n    validate,\n    validateField,\n    reorderListItem,\n    removeListItem,\n    insertListItem,\n    getInputProps,\n    onSubmit,\n    onReset,\n    isDirty,\n    isTouched,\n    setTouched,\n    setDirty,\n    resetTouched,\n    resetDirty,\n    isValid,\n    getTransformedValues,\n  };\n\n  useFormActions(name, form);\n\n  return form;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}