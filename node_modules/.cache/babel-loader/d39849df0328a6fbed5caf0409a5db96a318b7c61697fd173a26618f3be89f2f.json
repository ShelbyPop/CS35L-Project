{"ast":null,"code":"'use client';\n\nimport { filterErrors } from '../filter-errors/filter-errors.mjs';\nimport { getPath } from '../paths/get-path.mjs';\nimport 'klona/full';\nfunction getValidationResults(errors) {\n  const filteredErrors = filterErrors(errors);\n  return {\n    hasErrors: Object.keys(filteredErrors).length > 0,\n    errors: filteredErrors\n  };\n}\nfunction validateRulesRecord(rules, values, path = \"\", errors = {}) {\n  if (typeof rules !== \"object\" || rules === null) {\n    return errors;\n  }\n  return Object.keys(rules).reduce((acc, ruleKey) => {\n    const rule = rules[ruleKey];\n    const rulePath = `${path === \"\" ? \"\" : `${path}.`}${ruleKey}`;\n    const value = getPath(rulePath, values);\n    let arrayValidation = false;\n    if (typeof rule === \"function\") {\n      acc[rulePath] = rule(value, values, rulePath);\n    }\n    if (typeof rule === \"object\" && Array.isArray(value)) {\n      arrayValidation = true;\n      value.forEach((_item, index) => validateRulesRecord(rule, values, `${rulePath}.${index}`, acc));\n    }\n    if (typeof rule === \"object\" && typeof value === \"object\" && value !== null) {\n      if (!arrayValidation) {\n        validateRulesRecord(rule, values, rulePath, acc);\n      }\n    }\n    return acc;\n  }, errors);\n}\nfunction validateValues(validate, values) {\n  if (typeof validate === \"function\") {\n    return getValidationResults(validate(values));\n  }\n  return getValidationResults(validateRulesRecord(validate, values));\n}\nexport { validateValues };","map":{"version":3,"names":["getValidationResults","errors","filteredErrors","filterErrors","hasErrors","Object","keys","length","validateRulesRecord","rules","values","path","reduce","acc","ruleKey","rule","rulePath","value","getPath","arrayValidation","Array","isArray","forEach","_item","index","validateValues","validate"],"sources":["/Users/virounikamina/pompom/node_modules/@mantine/form/src/validate/validate-values.ts"],"sourcesContent":["import { filterErrors } from '../filter-errors';\nimport { getPath } from '../paths';\nimport { FormErrors, FormRule, FormRulesRecord, FormValidateInput } from '../types';\n\nfunction getValidationResults(errors: FormErrors) {\n  const filteredErrors = filterErrors(errors);\n  return { hasErrors: Object.keys(filteredErrors).length > 0, errors: filteredErrors };\n}\n\nfunction validateRulesRecord<T>(\n  rules: FormRulesRecord<T> | undefined,\n  values: T,\n  path = '',\n  errors: FormErrors = {}\n) {\n  if (typeof rules !== 'object' || rules === null) {\n    return errors;\n  }\n\n  return Object.keys(rules).reduce((acc, ruleKey) => {\n    const rule: FormRule<any, any> = (rules as any)[ruleKey];\n    const rulePath = `${path === '' ? '' : `${path}.`}${ruleKey}`;\n    const value = getPath(rulePath, values);\n    let arrayValidation = false;\n\n    if (typeof rule === 'function') {\n      acc[rulePath] = rule(value, values, rulePath);\n    }\n\n    if (typeof rule === 'object' && Array.isArray(value)) {\n      arrayValidation = true;\n      value.forEach((_item, index) =>\n        validateRulesRecord(rule, values, `${rulePath}.${index}`, acc)\n      );\n    }\n\n    if (typeof rule === 'object' && typeof value === 'object' && value !== null) {\n      if (!arrayValidation) {\n        validateRulesRecord(rule, values, rulePath, acc);\n      }\n    }\n\n    return acc;\n  }, errors);\n}\n\nexport function validateValues<T>(validate: FormValidateInput<T> | undefined, values: T) {\n  if (typeof validate === 'function') {\n    return getValidationResults(validate(values));\n  }\n\n  return getValidationResults(validateRulesRecord(validate, values));\n}\n"],"mappings":";;;;;AAGA,SAASA,oBAAoBA,CAACC,MAAM,EAAE;EACpC,MAAMC,cAAc,GAAGC,YAAY,CAACF,MAAM,CAAC;EAC3C,OAAO;IAAEG,SAAS,EAAEC,MAAM,CAACC,IAAI,CAACJ,cAAc,CAAC,CAACK,MAAM,GAAG,CAAC;IAAEN,MAAM,EAAEC;EAAc,CAAE;AACtF;AACA,SAASM,mBAAmBA,CAACC,KAAK,EAAEC,MAAM,EAAEC,IAAI,GAAG,EAAE,EAAEV,MAAM,GAAG,EAAE,EAAE;EAClE,IAAI,OAAOQ,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI,EAAE;IAC/C,OAAOR,MAAM;EACd;EACD,OAAOI,MAAM,CAACC,IAAI,CAACG,KAAK,CAAC,CAACG,MAAM,CAAC,CAACC,GAAG,EAAEC,OAAO,KAAK;IACjD,MAAMC,IAAI,GAAGN,KAAK,CAACK,OAAO,CAAC;IAC3B,MAAME,QAAQ,GAAI,GAAEL,IAAI,KAAK,EAAE,GAAG,EAAE,GAAI,GAAEA,IAAK,GAAG,GAAEG,OAAQ,EAAC;IAC7D,MAAMG,KAAK,GAAGC,OAAO,CAACF,QAAQ,EAAEN,MAAM,CAAC;IACvC,IAAIS,eAAe,GAAG,KAAK;IAC3B,IAAI,OAAOJ,IAAI,KAAK,UAAU,EAAE;MAC9BF,GAAG,CAACG,QAAQ,CAAC,GAAGD,IAAI,CAACE,KAAK,EAAEP,MAAM,EAAEM,QAAQ,CAAC;IAC9C;IACD,IAAI,OAAOD,IAAI,KAAK,QAAQ,IAAIK,KAAK,CAACC,OAAO,CAACJ,KAAK,CAAC,EAAE;MACpDE,eAAe,GAAG,IAAI;MACtBF,KAAK,CAACK,OAAO,CACX,CAACC,KAAK,EAAEC,KAAK,KAAKhB,mBAAmB,CAACO,IAAI,EAAEL,MAAM,EAAG,GAAEM,QAAS,IAAGQ,KAAM,EAAC,EAAEX,GAAG,CACvF,CAAO;IACF;IACD,IAAI,OAAOE,IAAI,KAAK,QAAQ,IAAI,OAAOE,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI,EAAE;MAC3E,IAAI,CAACE,eAAe,EAAE;QACpBX,mBAAmB,CAACO,IAAI,EAAEL,MAAM,EAAEM,QAAQ,EAAEH,GAAG,CAAC;MACjD;IACF;IACD,OAAOA,GAAG;EACX,GAAEZ,MAAM,CAAC;AACZ;AACO,SAASwB,cAAcA,CAACC,QAAQ,EAAEhB,MAAM,EAAE;EAC/C,IAAI,OAAOgB,QAAQ,KAAK,UAAU,EAAE;IAClC,OAAO1B,oBAAoB,CAAC0B,QAAQ,CAAChB,MAAM,CAAC,CAAC;EAC9C;EACD,OAAOV,oBAAoB,CAACQ,mBAAmB,CAACkB,QAAQ,EAAEhB,MAAM,CAAC,CAAC;AACpE"},"metadata":{},"sourceType":"module","externalDependencies":[]}